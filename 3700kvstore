#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"


class LogEntry:
    def __init__(self, term, key, value):
        self.term = term
        self.key = key
        self.value = value

    def __str__(self):
        return str([self.term, self.key, self.value])


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.leader = BROADCAST  # contains the ID of the leader (as far as this replica knows)
        # if no leader, contains BROADCAST
        self.state = "follower"
        self.timeout = random.uniform(0.15, 0.3)  # election timeout to become candidate (in sec)
        self.term = 0

        self.my_votes = 0  # counter to keep track of all the votes I receive during election
        self.majority_bounder = (len(self.others) + 1) // 2 + 1
        # self.votedFor = None #candidate Id that received my vote in current term

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        self.log_counter = []  # to check if there's quorum to do commit

        self.state_machine = {}
        self.log = []

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_fail(self, dst, mid):
        # if no leader, self.leader will be "BROADCAST"
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "fail", "MID": mid}
        self.send(msg)

    def send_redirect(self, dst, mid):
        # if no leader, self.leader will be "BROADCAST"
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "redirect", "MID": mid}
        self.send(msg)

    def send_AppendEntry(self, log_key=None, log_value=None, index=0):
        # log_entry can be empty if it is just a heartbeat
        # Add self.term so that replicas know the change when there's a new leader

        if log_key is None:
            # send just a heartbeat
            msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "AppendEntry", "term": self.term,
                   "key": log_key}
        else:
            if len(self.log) < 2:
                l = None
            else:
                l = self.log[-2]
            msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "AppendEntry",
                   "term": self.term, "key": log_key, "value": log_value, "index": len(self.log) - 1, "i": index,
                   "pre_log": None}
        self.send(msg)

    def answer_get(self, dst, value, mid):
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "ok", "MID": mid, "value": value}
        self.send(msg)

    def answer_put(self, dst, mid):
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "ok", "MID": mid}
        self.send(msg)

    def send_commit(self, key, value):
        msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "commit", "term": self.term, "key": key,
               "value": value}
        self.send(msg)

    def get_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:
            # self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.answer_get(msg_dic["src"], self.state_machine[msg_dic['key']], msg_dic["MID"])

    def put_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:
            # self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.log.append(LogEntry(self.term, msg_dic["key"], msg_dic["value"]))

            self.log_counter.append({"counter": 0,
                                     "key": msg_dic["key"],
                                     "value": msg_dic["value"],
                                     "client": msg_dic["src"],
                                     "MID": msg_dic["MID"],
                                     "sent": False})  # start the counter to check if there's quorum

            # send appendEntry to followers
            self.send_AppendEntry(msg_dic["key"], msg_dic["value"], len(self.log_counter) - 1)

    def update_log(self, index, pre_log, log_list):

        if pre_log is not None:
            pre_key = pre_log.key
            pre_value = pre_log.value
            pre_term = pre_log.term

        if pre_log is None or (self.log[-1].term == pre_term and self.log[-1].key == pre_key and self.log[
            -1].value == pre_value and index == len(self.log)):
            # then our log is updated
            self.log.extend(log_list)
        else:
            # reject and ask for previous previous log entry until match
            msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "reject", "term": self.term,
                   "index_rejected": index}
            self.send(msg)

    def run(self):
        start_time = time.time()
        count = 0
        while True:
            count += 1
            # to make the code single-thread we write it in an event-driven style
            socks = select.select([self.socket], [], [], 0.01)[0]  # small timeout to not block the proces

            # we use count to regulate the heartbeat rate
            if count % 5 == 0 and self.state == "leader":
                # tell all replicas that I am the new leader with an empty AppendEntry
                # TODO DONT SEND HEARTBEAT IF OTHER MESSAGE SENT
                self.send_AppendEntry(None)

            if time.time() - start_time > self.timeout and self.state != "leader":
                print("*****TIMEOUT*****")
                self.term += 1
                self.state = "candidate"
                self.leader = BROADCAST
                self.my_votes = 0  # reset votes counter
                # request vote of the other replicas
                msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "RequestVote",
                       "term": self.term}
                self.send(msg)
                start_time = time.time()

            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = data.decode('utf-8')

                print("Received message '%s'" % (msg,), flush=True)

                msg_dic = json.loads(msg)  # msg is now a python dictionary

                if msg_dic["type"] == "get":
                    self.get_received(msg_dic)

                elif msg_dic["type"] == "put":
                    self.put_received(msg_dic)

                elif msg_dic["type"] == "RequestVote":
                    # I just vote the first one in the corresponfing term
                    # By doing this we also deny vote of candidate with a lower term number 
                    # TODO, deny also vote if the candidateâ€™s log is not updated
                    # i.e. if the last log entry has the same term, grant vote if candidate has a longer log
                    if self.term < msg_dic["term"]:
                        self.leader = BROADCAST
                        self.term = msg_dic["term"]
                        self.my_votes = 0

                        # vote for the candidate
                        print("vote sent to ", msg_dic["src"])
                        msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "vote",
                               "term": self.term}
                        self.send(msg)

                    start_time = time.time()

                elif msg_dic["type"] == "vote" and self.term == msg_dic["term"]:
                    self.my_votes += 1
                    print("-----------------vote received, votes received: ", self.my_votes)
                    print("self.my_votes: ", self.my_votes)
                    print("self.majority_bounder: ", self.majority_bounder)
                    # I add a vote because I vote for myself
                    if self.my_votes + 1 >= self.majority_bounder:
                        self.my_votes = 0
                        self.state = "leader"
                        self.leader = self.id
                        # send heartbeats to notify other servers of the new leader (me)
                        self.send_AppendEntry()

                    start_time = time.time()

                elif msg_dic["type"] == "AppendEntry":
                    # AppendEntries always reset timeout
                    start_time = time.time()

                    if self.term < msg_dic["term"]:
                        # a new leader has been elected
                        self.term = msg_dic["term"]
                        self.leader = msg_dic["src"]
                        self.state = "follower"

                    if msg_dic["key"] is not None:
                        # if key different than None update our log
                        term = msg_dic["term"]
                        key = msg_dic["key"]
                        value = msg_dic["value"]
                        self.update_log(msg_dic["index"], msg_dic["pre_log"], [LogEntry(term, key, value)])

                        msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "logged",
                               "term": self.term, "i": msg_dic["i"]}
                        self.send(msg)

                elif msg_dic["type"] == "logged":
                    i = msg_dic["i"]

                    self.log_counter[i]["counter"] += 1
                    print("......................", self.log_counter[i], ".........................")

                    # I add also my vote
                    if not self.log_counter[i]["sent"] and self.log_counter[i]["counter"] + 1 >= self.majority_bounder:
                        key = self.log_counter[i]["key"]
                        value = self.log_counter[i]["value"]
                        client = self.log_counter[i]["client"]
                        mid = self.log_counter[i]["MID"]

                        self.state_machine[key] = value
                        self.answer_put(client, mid)

                        # TODO TELL REPLICAS TO DO THE COMMIT TOO

                        self.log_counter[i]["sent"] = True

                        # send the commit to the followers
                        self.send_commit(key, value)

                elif msg_dic["type"] == "commit":
                    self.state_machine[msg_dic["key"]] = msg_dic["value"]

                elif msg_dic["type"] == "reject":
                    # update log entry of the replica

                    sub_log = self.log[msg_dic["index_rejected"] - 1:]
                    pre_sub_log = self.log[msg_dic["index_rejected"] - 2]

                    msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "update_log",
                           "term": self.term, "log_list": sub_log, "pre_sub_log": pre_sub_log,
                           "index": msg_dic["index_rejected"] - 1}
                    self.send(msg)

                elif msg_dic["type"] == "update_log":
                    self.update_log(msg_dic["index"], msg_dic["pre_sub_log"], msg_dic["sub_log"])



                else:
                    print("Operation not supported")

            if len(self.log) > 1:
                print("******************************************", self.log[-1])


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()

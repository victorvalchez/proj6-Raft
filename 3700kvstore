#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.leader = BROADCAST  # contains the ID of the leader (as far as this replica knows)
        # if no leader, contains BROADCAST
        self.state = "follower"
        self.timeout = random.uniform(0.15, 0.3)  # election timeout to become candidate (in sec)
        self.term = 0

        self.my_votes = 0  # counter to keep track of all the votes I receive during election
        self.majority_bounder = (len(self.others) + 1) // 2 + 1
        # self.votedFor = None #candidate Id that received my vote in current term

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        self.log_counter = []  # to check if there's quorum to do commit

        self.heartbeat_counter = {} # counter to trigger the heartbeat
        for id in others:
            self.heartbeat_counter[id] = 0

        self.state_machine = {}
        self.log = []

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def reset_counts(self, dst):
        if dst == BROADCAST:
            for key in self.heartbeat_counter:
                    self.heartbeat_counter[key] = 0
        else:
            self.heartbeat_counter[dst] = 0

    def send_fail(self, dst, mid):
        # if no leader, self.leader will be "BROADCAST"
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "fail", "MID": mid}
        self.send(msg)

    def send_redirect(self, dst, mid):
        # if no leader, self.leader will be "BROADCAST"
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "redirect", "MID": mid}
        self.send(msg)

    def send_AppendEntry(self, log_key=None, log_value=None, index=0):
        # Add self.term so that replicas know the change when there's a new leader
        if len(self.log) < 2:
            l = None
        else:
            l = self.log[-2]

        msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "AppendEntry",
                "term": self.term, "key": log_key, "value": log_value, "index": len(self.log) - 1, "i": index,
                "pre_log": l}
        self.send(msg)

        self.reset_counts(BROADCAST)

    def send_Heartbeat(self, id):
        msg = {"src": self.id, "dst": id, "leader": self.leader, "type": "AppendEntry", "term": self.term, "key": None}
        self.send(msg)

    def answer_get(self, dst, value, mid):
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "ok", "MID": mid, "value": value}
        self.send(msg)

    def answer_put(self, dst, mid):
        msg = {"src": self.id, "dst": dst, "leader": self.leader, "type": "ok", "MID": mid}
        self.send(msg)

    def send_commit(self, key, value):
        msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "commit", "term": self.term, "key": key,
               "value": value}
        self.send(msg)

        self.reset_counts(BROADCAST)

    def get_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:
            # self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.answer_get(msg_dic["src"], self.state_machine[msg_dic['key']], msg_dic["MID"])

    def put_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:
            # self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.log.append({"term": self.term,
                             "key": msg_dic["key"],
                             "value": msg_dic["value"]})

            self.log_counter.append({"counter": 0,
                                     "key": msg_dic["key"],
                                     "value": msg_dic["value"],
                                     "client": msg_dic["src"],
                                     "MID": msg_dic["MID"],
                                     "sent": False})  # start the counter to check if there's quorum

            # send appendEntry to followers
            self.send_AppendEntry(msg_dic["key"], msg_dic["value"], len(self.log_counter) - 1)

    def update_log(self, index, pre_log, log_list):

        if pre_log is not None:
            pre_key = pre_log["key"]
            pre_value = pre_log["value"]
            pre_term = pre_log["term"]

        if pre_log is None or (self.log[-1]["term"] == pre_term and self.log[-1]["key"] == pre_key and self.log[
            -1]["value"] == pre_value and index == len(self.log)):
            # then our log is updated
            self.log.extend(log_list)
        else:
            # reject and ask for previous previous log entry until match
            msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "reject", "term": self.term,
                   "index_rejected": index}
            self.send(msg)


    def candidateUpToDate(self, n_logs, last_log_term):

        if n_logs == 0:
            return len(self.log) == 0
        else:
            return last_log_term > self.log[-1]["term"] or \
                (last_log_term == self.log["term"]  and n_logs >= len(self.log))


    def run(self):
        start_time = time.time()
        while True:
            # to make the code single-thread we write it in an event-driven style
            socks = select.select([self.socket], [], [], 0.01)[0]  # small timeout to not block the proces

            if self.state == "leader":
                for key in self.heartbeat_counter:
                    self.heartbeat_counter[key] += 1

                    if self.heartbeat_counter[key] % 5 == 0:
                        self.send_Heartbeat(key)

            if time.time() - start_time > self.timeout and self.state != "leader":
                print("*****TIMEOUT*****")
                self.term += 1
                self.state = "candidate"
                self.leader = BROADCAST
                self.my_votes = 0  # reset votes counter
                # request vote of the other replicas
                if len(self.log) > 0:
                    msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "RequestVote",
                        "term": self.term, "n_logs": len(self.log), "last_log_term" : self.log[-1]["term"]}
                else:
                    msg = {"src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "RequestVote",
                        "term": self.term, "n_logs": 0, "last_log_term" : None}
                
                self.send(msg)
                start_time = time.time()

            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = data.decode('utf-8')

                print("Received message '%s'" % (msg,), flush=True)

                msg_dic = json.loads(msg)  # msg is now a python dictionary

                if msg_dic["type"] == "get":
                    self.get_received(msg_dic)

                elif msg_dic["type"] == "put":
                    self.put_received(msg_dic)
  
                ###################
                # Candidate operations
                ###################
                elif msg_dic["type"] == "RequestVote":
                    # I just vote the first one in the corresponding term, 
                    # However, we deny the vote if the log is not up to date
                    if self.term < msg_dic["term"] and self.candidateUpToDate(msg_dic["n_logs"],msg_dic["last_log_term"]):
                        self.leader = BROADCAST
                        self.term = msg_dic["term"]
                        self.my_votes = 0

                        # vote for the candidate if its log is up to date
                        print("vote sent to ", msg_dic["src"])
                        msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "vote",
                               "term": self.term}
                        self.send(msg)

                    start_time = time.time()

                elif msg_dic["type"] == "vote" and self.term == msg_dic["term"]:
                    self.my_votes += 1
                    print("-----------------vote received, votes received: ", self.my_votes)
                    print("self.my_votes: ", self.my_votes)
                    print("self.majority_bounder: ", self.majority_bounder)
                    # I add a vote because I vote for myself
                    if self.my_votes + 1 >= self.majority_bounder:
                        self.my_votes = 0
                        self.state = "leader"
                        self.leader = self.id
                        # send heartbeats to notify other servers of the new leader (me)
                        self.send_Heartbeat(BROADCAST)

                    start_time = time.time()

                ###################
                # Leader operations
                ###################

                elif msg_dic["type"] == "logged":
                    # check id quorum for logged entries
                    i = msg_dic["i"]

                    self.log_counter[i]["counter"] += 1
                    print("......................", self.log_counter[i], ".........................")

                    # I add also my vote
                    if not self.log_counter[i]["sent"] and self.log_counter[i]["counter"] + 1 >= self.majority_bounder:
                        key = self.log_counter[i]["key"]
                        value = self.log_counter[i]["value"]
                        client = self.log_counter[i]["client"]
                        mid = self.log_counter[i]["MID"]

                        self.state_machine[key] = value
                        self.answer_put(client, mid)

                        self.log_counter[i]["sent"] = True

                        # send the commit to the followers
                        self.send_commit(key, value)

                elif msg_dic["type"] == "reject":
                    # update log entry of the replica that rejected the log entry
                    sub_log = self.log[msg_dic["index_rejected"] - 1:]
                    pre_sub_log = self.log[msg_dic["index_rejected"] - 2]

                    msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "update_log",
                           "term": self.term, "log_list": sub_log, "pre_sub_log": pre_sub_log,
                           "index": msg_dic["index_rejected"] - 1}
                    self.send(msg)

                    self.reset_counts(msg_dic["src"])

                ###################
                # Follower operations
                ###################
                elif msg_dic["type"] == "AppendEntry":
                    if self.term < msg_dic["term"]:
                        # a new leader has been elected
                        self.term = msg_dic["term"]
                        self.leader = msg_dic["src"]
                        self.state = "follower"

                    if msg_dic["key"] is not None:
                        # if key different than None update our log
                        term = msg_dic["term"]
                        key = msg_dic["key"]
                        value = msg_dic["value"]
                        self.update_log(msg_dic["index"], msg_dic["pre_log"], [{"term":term,"key": key,"value": value}])

                        msg = {"src": self.id, "dst": msg_dic["src"], "leader": self.leader, "type": "logged",
                               "term": self.term, "i": msg_dic["i"]}
                        self.send(msg)

                    # AppendEntries always reset timeout
                    start_time = time.time()

                elif msg_dic["type"] == "commit":
                    #don't commit entries from previous leaders
                    if msg_dic["term"] >= self.term:
                        self.state_machine[msg_dic["key"]] = msg_dic["value"]

                        #reset timeout every time we receive a message from the current leader
                        start_time = time.time()

                elif msg_dic["type"] == "update_log":
                    # receive the log update from the leader
                    self.update_log(msg_dic["index"], msg_dic["pre_sub_log"], msg_dic["sub_log"])

                    #reset timeout every time we receive a message from the leader
                    start_time = time.time()



                else:
                    print("Operation not supported")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()

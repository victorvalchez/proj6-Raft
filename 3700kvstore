#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"

class LogEntry():
    def __init__(self, term, key, value):
        self.term = term
        self.key = key
        self.value = value


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.leader = BROADCAST # contains the ID of the leader (as far as this replica knows)
                                # if no leader, contains BROADCAST
        self.state = "follower"
        self.timeout = random.uniform(0.15, 0.3) # election timeout to become candidate (in sec)
        self.term = 0

        self.my_votes = 0 #counter to keep track of all the votes I receive during election
        self.majority_bounder = (len(self.others)+1)//2 + 1
        #self.votedFor = None #candidate Id that received my vote in current term

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        self.state_machine = {}
        self.log = []

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_fail(self, dst, mid):
        #if no leader, self.leader will be "BROADCAST"
        msg = {"src" : self.id, "dst" : dst, "leader": self.leader, "type" : "fail", "MID" : mid}
        self.send(msg)

    def send_redirect(self, dst, mid):
        #if no leader, self.leader will be "BROADCAST"
        msg = {"src" : self.id, "dst" : dst, "leader": self.leader, "type" : "redirect", "MID" : mid}
        self.send(msg)
    
    def send_AppendEntry(self, log_entry):
        # log_entry can be empty if it is just a heartbeat
        # Add self.term so that replicas know the change when there's a new leader
        msg = {"src" : self.id, "dst" : BROADCAST, "leader": self.leader, "type" : "AppendEntry", "term": self.term, "log_entry": log_entry}
        self.send(msg)

    def answer_get(self, dst, value, mid):
        msg = {"src" : self.id, "dst" : dst, "leader": self.leader, "type" : "ok", "MID" : mid, "value" : value}
        self.send(msg)

    def answer_put(self, dst, mid):
        msg = {"src" : self.id, "dst" : dst, "leader": self.leader, "type" : "ok", "MID" : mid}
        self.send(msg)

    def get_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:   
            #self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.answer_get(msg_dic["src"], self.state_machine[msg_dic['key']], msg_dic["MID"])

    def put_received(self, msg_dic):
        if self.state != "leader":
            self.send_redirect(msg_dic['src'], msg_dic["MID"])
        else:   
            #self.send_fail(msg_dic["src"], msg_dic["MID"])
            self.log.append(LogEntry(self.term, msg_dic["key"], msg_dic["value"]))
            self.state_machine[msg_dic["key"]] = msg_dic["value"]

            self.answer_put(msg_dic["src"], msg_dic["MID"])

    def run(self):
        start_time = time.time()
        count = 0
        while True:
            count+=1
            # to make the code single-thread we write it in an event-driven style
            socks = select.select([self.socket], [], [], 0.01)[0] # small timeout to not block the proces

            # we use count to regulate the heartbeat rate
            if count % 5 == 0 and self.state == "leader":
                # tell all replicas that I am the new leader with an empty AppendEntry
                self.send_AppendEntry(None)
                
            if time.time() - start_time > self.timeout and self.state != "leader":
                print("*****TIMEOUT*****")
                self.term += 1
                self.state = "candidate"
                self.leader = BROADCAST
                self.my_votes = 0 # reset votes counter
                # request vote of the other replicas
                msg = {"src" : self.id, "dst": BROADCAST, "leader": self.leader, "type" : "RequestVote", "term" : self.term}
                self.send(msg)
                start_time = time.time()
                

            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = data.decode('utf-8')

                print("Received message '%s'" % (msg,), flush=True)

                msg_dic = json.loads(msg)  # msg is now a python dictionary

                if msg_dic["type"] == "get":
                    self.get_received(msg_dic)

                elif msg_dic["type"] == "put":
                    self.put_received(msg_dic)

                elif msg_dic["type"] == "RequestVote":
                    # I just vote the first one in the corresponfing term
                    # By doing this we also deny vote of candidate with a lower term number 
                    # TODO, deny also vote if the candidateâ€™s log is not updated
    		        # i.e. if the last log entry has the same term, grant vote if candidate has a longer log
                    if self.term < msg_dic["term"]:
                        self.leader = BROADCAST
                        self.term = msg_dic["term"]
                        self.my_votes = 0
                        
                        #vote for the candidate
                        print("vote sent to ", msg_dic["src"])
                        msg = {"src" : self.id, "dst" : msg_dic["src"], "leader": self.leader, "type" : "vote", "term" : self.term}
                        self.send(msg)

                    start_time = time.time()


                elif msg_dic["type"] == "vote" and self.term == msg_dic["term"]:
                    self.my_votes += 1
                    print("-----------------vote received, votes received: ", self.my_votes)
                    print("self.my_votes: ", self.my_votes)
                    print("self.majority_bounder: ", self.majority_bounder)
                    # I add a vote because I vote for myself
                    if self.my_votes + 1 >= self.majority_bounder:
                        self.my_votes = 0
                        self.state = "leader"
                        self.leader = self.id
                        # send heartbeats to notify other servers of the new leader (me)
                        self.send_AppendEntry(None)
                        

                    start_time = time.time()

                elif msg_dic["type"] == "AppendEntry":
                    # AppendEntries always reset timeout
                    start_time = time.time()

                    if self.term < msg_dic["term"]:
                        # a new leader has been elected
                        self.term = msg_dic["term"]
                        self.leader = msg_dic["src"]
                        self.state = "follower"

                    # check if there was a log request in the message
                    if msg_dic["log_entry"] is not None:
                        pass
                        #TODO

                else:
                    print("Operation not supported")




if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
